#!/bin/bash

set -e
VERSION="1.0.0"
WORKDIR="/tmp/mkobsidianiso-$$"
DISTRO="ObsidianOS"                        # config
ISO_NAME="OBSIDIANOS"                      # config
ISO_VERSION="1.0.0"                        # config
EXTRA_GRUB_CONFIG=""                       # config
BUSYBOX=""                                 # config
EXTRA_BOOT_OPT=""                          # config
BINARIES=""                                # config
EXTRA_MODULES=""                           # config
EXTRA_FILES=""                             # config
MEMTEST_EFI="/boot/memtest86+/memtest.efi" # config
ENABLE_TORAM="1"                           # config
error() {
  echo "ERROR: $*" >&2
  exit 1
}

info() {
  echo "=> $*"
}

cleanup() {
  info "Cleaning up..."
  umount "$WORKDIR" || true
  rm -rf "$WORKDIR"
}

trap cleanup EXIT
show_help() {
  cat <<EOF
mkobsidianiso - Create bootable live ISO from a system image

Usage: mkobsidianiso [OPTIONS] <config> <rootfs> <output.iso>

Arguments:
  <config>        Config file path
  <rootfs>        Source root filesystem (directory or squashfs system image)
  <output.iso>    Output ISO file path

Config options:
  DISTRO            Distro name in the GRUB menu
  ISO_NAME          ISO File Product Name
  ISO_VERSION       ISO File Product Version
  EXTRA_GRUB_CONFIG Extra options like menu entries for GRUB
  BUSYBOX           Busybox binary path
  EXTRA_BOOT_OPT    Extra boot options like "quiet splash"
  BINARIES          Binary file paths to copy
  EXTRA_MODULES     Extra kernel modules to copy and decompress
  EXTRA_FILES       Extra files to copy to the ISO and bind-mount

Options:
  -k, --kernel    Specify kernel version (auto-detect if not provided)
  -h, --help      Show this help message
  -v, --version   Show version

Examples:
  mkobsidianiso config.conf /path/to/rootfs output.iso
  mkobsidianiso -k 6.12.62_1 config.conf rootfs.sfs output.iso

EOF
}

detect_kernel() {
  local rootfs="$1"
  local mount_needed=false
  local mount_point=""
  if [[ -f "$rootfs" ]]; then
    mount_point="$WORKDIR/detect_mount"
    mkdir -p "$mount_point"
    mount -o loop,ro "$rootfs" "$mount_point" 2>/dev/null || error "Failed to mount $rootfs for kernel detection"
    mount_needed=true
    rootfs="$mount_point"
  fi
  local kernel_file=$(ls "$rootfs/boot/vmlinuz-"* 2>/dev/null | head -n1)
  if [[ -z "$kernel_file" ]]; then
    kernel_file=$(ls "$rootfs/boot/vmlinuz"* 2>/dev/null | head -n1)
  fi
  if [[ -z "$kernel_file" ]]; then
    kernel_file=$(ls "$rootfs/boot/kernel-"* 2>/dev/null | head -n1)
  fi
  if [[ -z "$kernel_file" ]]; then
    kernel_file=$(ls "$rootfs/boot/kernel"* 2>/dev/null | head -n1)
  fi
  if $mount_needed; then
    umount "$mount_point"
  fi
  [[ -z "$kernel_file" ]] && error "Could not detect kernel file. Use -k to specify manually."
  echo "$kernel_file"
}

detect_initramfs_format() {
  local rootfs="$1"
  local kernel_file="$2"
  local mount_needed=false
  local mount_point=""
  if [[ -f "$rootfs" ]]; then
    mount_point="$WORKDIR/detect_mount"
    mkdir -p "$mount_point"
    mount -o loop,ro "$rootfs" "$mount_point" 2>/dev/null || error "Failed to mount $rootfs for initramfs detection"
    mount_needed=true
    rootfs="$mount_point"
  fi
  local kernel_version=$(get_kernel_version_from_file "$kernel_file" h)
  local initramfs_format=""
  if [[ -f "$rootfs/boot/initramfs-$kernel_version.img" ]]; then
    initramfs_format="initramfs"
  elif [[ -f "$rootfs/boot/initrd-$kernel_version.img" ]]; then
    initramfs_format="initrd"
  elif [[ -f "$rootfs/boot/initramfs-$kernel_version" ]]; then
    initramfs_format="initramfs_no_ext"
  elif [[ -f "$rootfs/boot/initrd-$kernel_version" ]]; then
    initramfs_format="initrd_no_ext"
  elif [[ -f "$rootfs/boot/initramfs.img-$kernel_version" ]]; then
    initramfs_format="initramfs_img_prefix"
  elif [[ -f "$rootfs/boot/initrd.img-$kernel_version" ]]; then
    initramfs_format="initrd_img_prefix"
  fi
  if $mount_needed; then
    umount "$mount_point"
  fi
  echo "$initramfs_format"
}

extract_modules() {
  local rootfs="$1"
  local kernel_file="$2"
  local dest="$3"
  local mount_needed=false
  local mount_point=""
  declare -A decompressors
  decompressors[".zst"]="unzstd"
  decompressors[".gz"]="gunzip"
  decompressors[".xz"]="unxz -k"
  decompressors[".bz2"]="bunzip2"
  decompressors[".lz4"]="lz4 -d"
  if [[ -f "$rootfs" ]]; then
    mount_point="$WORKDIR/module_mount"
    mkdir -p "$mount_point"
    mount -o loop,ro "$rootfs" "$mount_point" || error "Failed to mount $rootfs"
    mount_needed=true
    rootfs="$mount_point"
  fi
  local kernel_version=$(get_kernel_version_from_file "$kernel_file")
  echo $kernel_file
  local mod_dir="$rootfs/lib/modules/$kernel_version/kernel"
  [[ ! -d "$mod_dir" ]] && error "Kernel modules not found at $mod_dir"
  info "Extracting kernel modules..."
  local mandatory_modules=(
    "fs/squashfs/squashfs.ko"
    "drivers/block/loop.ko"
    "fs/overlayfs/overlay.ko"
  )

  local all_modules=("${mandatory_modules[@]}" ${EXTRA_MODULES})
  for mod_path in "${all_modules[@]}"; do
    local src_found=false
    local src_file=""
    local module_base=$(basename "$mod_path")
    if [[ -f "$mod_dir/$mod_path" ]]; then
      src_file="$mod_dir/$mod_path"
      src_found=true
    fi

    if ! $src_found; then
      for ext in "${!decompressors[@]}"; do
        if [[ -f "$mod_dir/$mod_path$ext" ]]; then
          local decompress_cmd_full="${decompressors[$ext]}"
          local decompress_cmd_bin=$(echo "$decompress_cmd_full" | cut -d ' ' -f1)
          if command -v "$decompress_cmd_bin" &>/dev/null; then
            info "mod: $mod_path$ext. Decompressing..."
            cp "$mod_dir/$mod_path$ext" "$dest/$module_base$ext" || error "mod: Failed to copy $mod_path$ext"
            (cd "$dest" && $decompress_cmd_full "$module_base$ext" && rm "$module_base$ext") || error "mod: Failed to decompress $module_base$ext"
            src_file="$dest/$module_base"
            src_found=true
            break
          else
            info "WARN: Decompressor '$decompress_cmd_bin' not found. Cannot decompress $mod_path$ext. Skipping."
          fi
        fi
      done
    fi

    if ! $src_found; then
      error "mod: not found: $mod_path (neither uncompressed nor supported compressed versions)"
    elif [[ "$src_file" != "$dest/$module_base" ]]; then
      cp "$src_file" "$dest/"
    fi
  done

  if $mount_needed; then
    umount "$mount_point"
  fi
}

create_init_script() {
  local dest="$1"
  cat >"$dest" <<'INITEOF'
#!/sbin/busybox sh
clear
echo "=> mkobsidianiso"
get_opt() {
    local val=$(cat /proc/cmdline | tr ' ' '\n' | grep "^$1=" | cut -d= -f2-)
    [ -n "$val" ] && echo "$val"
}

has_opt() {
    grep -q "\<$1\>" /proc/cmdline
}
echo "=> inserting kernel modules"
if has_opt "obsidian.safemode"; then
    echo "!!! SAFE MODE ENABLED !!!"
    insmod /extras/loop.ko 2>/dev/null
    insmod /extras/squashfs.ko 2>/dev/null
    insmod /extras/overlay.ko 2>/dev/null
else
    for f in /extras/*.ko; do
        insmod $f || (echo "=> ERROR: failed to insert $f"; sleep 1000)
    done
fi
if has_opt "obsidian.serial"; then
    exec > /dev/ttyS0 2>&1
fi
echo "=> setting up loopback device"
mknod /dev/loop0 b 7 0 2>/dev/null
if has_opt "obsidian.toram"; then
    echo "=> copying system to RAM (this may take a moment)..."
    mount -t tmpfs tmpfs /tmp 2>/dev/null
    SIZE=$(stat -c%s "/live/system.sfs")
    SRC="/live/system.sfs"
    if [ -f "$SRC" ]; then
        SIZE=$(stat -c%s "$SRC")
        echo "=> relocating $((SIZE / 1024 / 1024 / 1024))GiB to RAM..."
        cp "$SRC" "/tmp/system.sfs" &
        CP_PID=$!
        while kill -0 $CP_PID 2>/dev/null; do
            CUR=$(stat -c%s "/tmp/system.sfs" 2>/dev/null || echo 0)
            PCT=$(( 100 * $CUR / $SIZE ))
            BAR_WIDTH=$(( PCT / 5 ))
            BAR=$(printf "%${BAR_WIDTH}s" | tr ' ' '#')
            printf "\r=> progress: [%-25s] %d%%" "$BAR" "$PCT"
            sleep 0.1
        done
        echo -e "\n=> copy complete. mounting from RAM..."
    fi
    losetup /dev/loop0 /tmp/system.sfs
else
    losetup /dev/loop0 /live/system.sfs
fi
echo "=> mounting overlay"
mkdir -p /lower /upper /work /newroot 2>/dev/null
mount -t squashfs /dev/loop0 /lower 2>/dev/null
mount -t tmpfs tmpfs /upper 2>/dev/null
mkdir -p /upper/upper /upper/work 2>/dev/null
mount -t overlay overlay -o lowerdir=/lower,upperdir=/upper/upper,workdir=/upper/work /newroot 2>/dev/null
echo "=> moving essential mounts"
mount --move /dev /newroot/dev 2>/dev/null
mount -t proc proc /newroot/proc
mount -t sysfs sysfs /newroot/sys
NEW_HOST=$(get_opt "obsidian.hostname")
if [ -n "$NEW_HOST" ]; then
    echo "$NEW_HOST" > /newroot/etc/hostname
fi
echo "=> changing root"
cd /newroot
if has_opt "obsidian.debug"; then
    echo "!!! DEBUG MODE DETECTED !!!"
    /sbin/busybox sh
fi
pivot_root . tmp || (echo "=> ERROR: UNABLE TO PIVOT ROOT (VERY CRITICAL!!!)" && sleep 1000)
echo "=> mounting the live CD at /mnt/livecd"
mkdir -p /mnt/livecd
mount --move /tmp/ /mnt/livecd
echo "=> bind-mounting extra files recursively"
if has_opt "obsidian.debug"; then
    echo "!!! DEBUG MODE DETECTED !!!"
    /sbin/busybox sh
fi
_bind_mount() {
  local src_path="$1"
  local dst_path="$2"
  if [ -f "$src_path" ]; then
    if [ -d "$dst_path" ]; then
      echo "=> WARN: cannot bind file $src_path to existing directory $dst_path. skipping." >&2
      return 1
    fi
    [ ! -e "$dst_path" ] && touch "$dst_path"
    if ! mount --bind "$src_path" "$dst_path"; then
      echo "=> ERROR: failed to bind-mount file $src_path to $dst_path" >&2
      return 1
    fi
  elif [ -d "$src_path" ]; then
    if [ -e "$dst_path" ]; then
      if [ -d "$dst_path" ]; then
        for item in "$src_path"/*; do
          local item_name=${item#/mnt/livecd/extras/files/}
          _bind_mount "$item" "$item_name"
          if [ $? -ne 0 ]; then return 1; fi
        done
      else
        echo "=> WARN: cannot bind directory $src_path to existing non-directory $dst_path. skipping." >&2
        return 1
      fi
    else
      mkdir -p "$dst_path"
      if ! mount --bind "$src_path" "$dst_path"; then
        echo "=> ERROR: failed to bind-mount directory $src_path to $dst_path" >&2
        return 1
      fi
    fi
  else
    echo "=> WARN: source $src_path is neither a file nor a directory. skipping." >&2
    return 0
  fi
  return 0
}
if has_opt "obsidian.nobind" || has_opt "obsidian.safemode"; then
    echo "=> skipping extra files"
else
    for f in /mnt/livecd/extras/files/*; do
      filename="${f#/mnt/livecd/extras/files/}"
      target="/${filename%/}"
      _bind_mount "$f" "$target" || sleep 1000
    done
fi
echo "=> symlinking (forcefully!) system image to /etc/system.sfs"
ln -sf /mnt/livecd/live/system.sfs /etc/system.sfs || (echo "=> ERROR: UNABLE TO SYMLINK SYSTEM IMAGE" && sleep 1000)
echo "=> symlinking extra binaries"
for f in /mnt/livecd/extras/binaries/*; do
    [ -f "$f" ] || (echo "=> WARN: skipping $f due to not being a file"; continue)
    ln -sf "$f" /usr/bin/
done
echo "=> giving the job to the system. bye from mkobsidianiso"
if has_opt "obsidian.shell"; then
    echo "=> dropping to shell before switching to the system. type 'exit' to continue boot."
    /sbin/busybox sh
fi
exec /sbin/init
INITEOF
  chmod +x "$dest"
}

get_kernel_version_from_file() {
  local kernel_file="$1"
  if [ $2 == "h" ]; then
    echo "$kernel_file" | xargs basename | sed -e 's/^vmlinuz-//' -e 's/^kernel-//' -e 's/^vmlinuz//' -e 's/^kernel//'
  else
    echo $(file "$kernel_file" | grep -oP 'version \K[^\s,]+')
  fi
}

create_grub_cfg() {
  local dest="$1"
  local kernel_file="$2"
  local rootfs="$3"
  local toramline=""
  local nontoramline=""
  if [[ "$ENABLE_TORAM" == "1" ]]; then
    toramline="obsidian.toram"
    nontoramline=""
  else
    toramline=""
    nontoramline="obsidian.toram"
  fi
  local kernel_version=$(get_kernel_version_from_file "$kernel_file")
  local initramfs_format=$(detect_initramfs_format "$rootfs" "$kernel_file")
  [[ -z "$initramfs_format" ]] && error "Could not detect initramfs format for kernel $kernel_version"
  local initrd_path=""
  case "$initramfs_format" in
  "initramfs") initrd_path="/boot/initramfs-$kernel_version.img" ;;
  "initrd") initrd_path="/boot/initrd-$kernel_version.img" ;;
  "initramfs_no_ext") initrd_path="/boot/initramfs-$kernel_version" ;;
  "initrd_no_ext") initrd_path="/boot/initrd-$kernel_version" ;;
  "initramfs_img_prefix") initrd_path="/boot/initramfs.img-$kernel_version" ;;
  "initrd_img_prefix") initrd_path="/boot/initrd.img-$kernel_version" ;;
  esac
  cat >"$dest" <<EOF
set default=0
set timeout=10
menuentry "$DISTRO" {
    echo "=> finding system image"
    search --no-floppy --set=root --file /live/system.sfs
    echo "=> mounting system image"
    loopback loop0 (\$root)/live/system.sfs
    echo "=> loading linux"
    linux (loop0)/boot/$kernel_file root=LABEL=OBOS_$ISO_NAME rootfstype=iso9660 ro $toramline $EXTRA_BOOT_OPT
    echo "=> loading initramfs"
    initrd (loop0)$initrd_path
    echo "=> booting"
    boot
}

submenu 'Advanced Options for $DISTRO' {
    menuentry "$DISTRO (Safe Mode)" {
        echo "=> finding system image"
        search --no-floppy --set=root --file /live/system.sfs
        echo "=> mounting system image"
        loopback loop0 (\$root)/live/system.sfs
        echo "=> loading linux"
        linux (loop0)/boot/$kernel_file root=LABEL=OBOS_$ISO_NAME ro obsidian.safemode obsidian.debug $EXTRA_BOOT_OPT
        echo "=> loading initramfs"
        initrd (loop0)$initrd_path
        echo "=> booting"
        boot
    }

    menuentry "$DISTRO (ToRAM Toggle)" {
        echo "=> finding system image"
        search --no-floppy --set=root --file /live/system.sfs
        echo "=> mounting system image"
        loopback loop0 (\$root)/live/system.sfs
        echo "=> loading linux"
        linux (loop0)/boot/$kernel_file root=LABEL=OBOS_$ISO_NAME ro $nontoramline $EXTRA_BOOT_OPT
        echo "=> loading initramfs"
        initrd (loop0)$initrd_path
        echo "=> booting"
        boot
    }

    menuentry "$DISTRO (Debug Mode)" {
        echo "=> finding system image"
        search --no-floppy --set=root --file /live/system.sfs
        echo "=> mounting system image"
        loopback loop0 (\$root)/live/system.sfs
        echo "=> loading linux"
        linux (loop0)/boot/$kernel_file root=LABEL=OBOS_$ISO_NAME ro obsidian.debug $EXTRA_BOOT_OPT
        echo "=> loading initramfs"
        initrd (loop0)$initrd_path
        echo "=> booting"
        boot
    }

    menuentry "$DISTRO (No Modeset - Basic Graphics)" {
        echo "=> finding system image"
        search --no-floppy --set=root --file /live/system.sfs
        echo "=> mounting system image"
        loopback loop0 (\$root)/live/system.sfs
        echo "=> loading linux"
        linux (loop0)/boot/$kernel_file root=LABEL=OBOS_$ISO_NAME ro nomodeset $EXTRA_BOOT_OPT
        echo "=> loading initramfs"
        initrd (loop0)$initrd_path
        echo "=> booting"
        boot
    }
}

submenu 'System Utilities...' {
    submenu 'Hardware Diagnostics...' {
        if [ -f /boot/memtest/memtest.efi ]; then
            menuentry "Memtest86+ (UEFI)" {
                insmod efi_gop
                chainloader /boot/memtest/memtest.efi
            }
        fi
        menuentry "List Storage Devices" {
            ls -l
            echo "Press any key to return..."
            getkey
        }
        menuentry "Memory Map" {
            lsmmap
            echo "Press any key to return..."
            getkey
        }
    }
    menuentry "Reboot" {
        reboot
    }
    menuentry "Shutdown" {
        halt
    }
}

$EXTRA_GRUB_CONFIG
EOF
}

create_squashfs() {
  local src="$1"
  local dest="$2"
  info "Creating system image from $src..."
  mksquashfs "$src" "$dest" -comp xz -b 1M -Xdict-size 100% -p || error "Failed to create squashfs"
}

main() {
  old_pwd="$PWD"
  local kernel_file=""
  local rootfs=""
  local output=""
  local config=""
  while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
      show_help
      exit 0
      ;;
    -v | --version)
      echo "mkobsidianiso $VERSION"
      exit 0
      ;;
    -k | --kernel)
      kernel_file="$2"
      shift 2
      ;;
    -*)
      error "Unknown option: $1"
      ;;
    *)
      if [[ -z "$config" ]]; then
        config="$1"
        source "$config"
      else
        if [[ -z "$rootfs" ]]; then
          rootfs="$1"
        elif [[ -z "$output" ]]; then
          output="$1"
        else
          error "Too many arguments"
        fi
      fi
      shift
      ;;
    esac
  done

  [[ -z "$rootfs" ]] && error "No rootfs specified. Use -h for help."
  [[ -z "$output" ]] && error "No output file specified. Use -h for help."
  [[ ! -e "$rootfs" ]] && error "Rootfs not found: $rootfs"
  [[ ! -e "$config" ]] && error "Config file not specified."
  [[ $EUID -ne 0 ]] && error "This script must be run as root"
  command -v mksquashfs &>/dev/null || error "mksquashfs not found. Install squashfs-tools."
  command -v grub-mkrescue &>/dev/null || error "grub-mkrescue not found. Install grub."
  mkdir -p "$WORKDIR"
  if [[ -z "$kernel_file" ]]; then
    info "Auto-detecting kernel file..."
    kernel_file=$(detect_kernel "$rootfs")
  fi
  info "Using kernel file: $kernel_file"
  local iso_root="$WORKDIR/iso"
  mkdir -p "$iso_root"/{boot/grub,sbin,extras/binaries,extras/files,live,dev,proc,sys,newroot,lower,upper/{work,upper},work,tmp}
  local squashfs_file="$iso_root/live/system.sfs"
  if [[ -d "$rootfs" ]]; then
    create_squashfs "$rootfs" "$squashfs_file"
  elif [[ -f "$rootfs" ]]; then
    info "Using existing squashfs: $rootfs"
    cp "$rootfs" "$squashfs_file"
  else
    error "Invalid rootfs type"
  fi
  extract_modules "$squashfs_file" "$kernel_file" "$iso_root/extras"
  info "Adding extra files/directories"
  if [[ -n "$EXTRA_FILES" ]]; then
    for f in $EXTRA_FILES; do
      if [[ ! -e "$f" ]]; then
        error "Extra file or directory not found: $f"
      fi

      local dest_parent_dir="$iso_root/extras/files$(dirname "$f")"
      info "Copying $f to $dest_parent_dir/"
      mkdir -p "$dest_parent_dir" || error "Failed to create directory $dest_parent_dir"
      cp -r "$f" "$dest_parent_dir/" || error "Failed to copy $f"
    done
  fi
  info "Installing busybox..."
  if [ -f "$BUSYBOX" ]; then
    cp "$BUSYBOX" "$iso_root/sbin/busybox"
  else
    if command -v busybox &>/dev/null; then
      cp "$(command -v busybox)" "$iso_root/sbin/"
    else
      error "busybox not found. Please install busybox-static. Or run $(curl -fsSL https://files.obsidianos.xyz/~odd/static/busybox -o /usr/bin/)"
    fi
  fi
  mkdir -p "$iso_root/boot/memtest"
  [ -f "$MEMTEST_EFI" ] && cp "$MEMTEST_EFI" "$iso_root/boot/memtest/memtest.efi"
  info "Creating init script..."
  create_init_script "$iso_root/sbin/init"
  info "Creating os-release"
  mkdir -p "$iso_root/etc/"
  cat >"$iso_root/etc/os-release" <<'EOF'
NAME="mkobsidianiso"
PRETTY_NAME="GNU/Linux"
ID=obsidian
BUILD_ID=iso
ANSI_COLOR="38;2;23;147;209"
HOME_URL=""
DOCUMENTATION_URL=""
SUPPORT_URL=""
BUG_REPORT_URL=""
PRIVACY_POLICY_URL=""
LOGO=obsidianos
EOF
  info "Creating GRUB configuration..."
  create_grub_cfg "$iso_root/boot/grub/grub.cfg" "$kernel_file" "$rootfs"
  info "Adding extra binaries"
  cp $BINARIES "$iso_root/extras/binaries/" || true
  info "Building ISO with grub-mkrescue..."
  cd "$old_pwd"
  grub-mkrescue -o "$output" "$iso_root" --product-name="$ISO_NAME" --product-version="$ISO_VERSION" -- -volid "OBOS_$ISO_NAME" || error "Failed to create ISO"
  info "Success! ISO created at: $output"
  info "Size: $(du -h "$output" | cut -f1)"
}

main "$@"
